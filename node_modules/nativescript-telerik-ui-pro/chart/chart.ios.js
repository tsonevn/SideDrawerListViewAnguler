"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var commonModule = require("./chart-common");
var color_1 = require("color");
var initializersImpl = require("./chart-initializers");
require("utils/module-merge").merge(commonModule, exports);
var ChartDelegateImpl = (function (_super) {
    __extends(ChartDelegateImpl, _super);
    function ChartDelegateImpl() {
        _super.apply(this, arguments);
    }
    ChartDelegateImpl.new = function () {
        return _super.new.call(this);
    };
    ChartDelegateImpl.prototype.initWithOwner = function (owner) {
        this._owner = owner;
        return this;
    };
    ChartDelegateImpl.prototype.chartDidSelectSeries = function (chart, series) {
        var selectedSeries = null;
        for (var i = 0; i < this._owner.series.length; i++) {
            if (this._owner.series[i].ios.index == series.index) {
                selectedSeries = this._owner.series[i];
                break;
            }
        }
        var args = { eventName: commonModule.RadChartBase.seriesSelectedEvent,
            object: this._owner,
            series: selectedSeries,
            pointIndex: null,
            pointData: null };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidDeselectSeries = function (chart, series) {
        var deselectedSeries = null;
        for (var i = 0; i < this._owner.series.length; i++) {
            if (this._owner.series[i].ios.index == series.index) {
                deselectedSeries = this._owner.series[i];
                break;
            }
        }
        var args = { eventName: commonModule.RadChartBase.seriesDeselectedEvent,
            object: this._owner,
            series: deselectedSeries,
            pointIndex: null,
            pointData: null };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidSelectPointInSeriesAtIndex = function (chart, point, series, index) {
        var args = { eventName: commonModule.RadChartBase.pointSelectedEvent,
            object: this._owner,
            series: series,
            pointIndex: index.intValue,
            pointData: point };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidDeselectPointInSeriesAtIndex = function (chart, point, series, index) {
        var args = { eventName: commonModule.RadChartBase.pointDeselectedEvent,
            object: this._owner,
            series: series,
            pointIndex: index.intValue,
            pointData: point };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidZoom = function (chart) {
        var args = { eventName: commonModule.RadChartBase.chartZoomedEvent,
            object: this._owner,
            pointData: null,
            pointIndex: null,
            series: null };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartDidPan = function (chart) {
        var args = { eventName: commonModule.RadChartBase.chartPannedEvent,
            object: this._owner,
            pointData: null,
            pointIndex: null,
            series: null };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartTrackballDidTrackSelection = function (chart, selection) {
        var args = { eventName: commonModule.RadChartBase.trackballTrackedSelectionEvent,
            object: this._owner,
            selection: selection };
        this._owner.notify(args);
    };
    ChartDelegateImpl.prototype.chartPaletteItemForSeriesAtIndex = function (chart, series, index) {
        if (series.isSelected && TKChartSeriesSelectionMode.TKChartSeriesSelectionModeSeries == series.selectionMode) {
            return this._owner.getSelectionPaletteItemWithIndexForSeries(series.index, series.tag);
        }
        if (TKChartSeriesSelectionMode.TKChartSeriesSelectionModeDataPoint == series.selectionMode && series.pointIsSelected(index)) {
            if (this._owner instanceof RadPieChart) {
                if (this._owner.chartSelectionPalette) {
                    return this._owner.chartSelectionPalette.items[index % this._owner.chartSelectionPalette.items.count];
                }
                else {
                    return null;
                }
            }
            return this._owner.getSelectionPaletteItemWithIndexForSeries(series.index, series.tag);
        }
        return null;
    };
    ChartDelegateImpl.ObjCProtocols = [TKChartDelegate];
    return ChartDelegateImpl;
}(NSObject));
////////////////////////////////////////////////////////////////////
var RadPieChart = (function (_super) {
    __extends(RadPieChart, _super);
    function RadPieChart() {
        _super.call(this);
        this._loaded = false;
        this._ios = TKChart.new();
        this._delegate = ChartDelegateImpl.new().initWithOwner(this);
        this._ios.selectionMode = TKChartSelectionMode.TKChartSelectionModeSingle;
        this._ios.allowAnimations = true;
    }
    Object.defineProperty(RadPieChart.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    RadPieChart.prototype.addSeries = function (newSeries) {
        this.ios.removeAllData();
        this.ios.addSeries(newSeries);
        if (this.palettes) {
            this.loadPalette(this.palettes);
        }
        if (this._chartPalette) {
            this.series[0].ios.style.palette = this._chartPalette;
            this.series[0].ios.style.paletteMode = TKChartSeriesStylePaletteMode.TKChartSeriesStylePaletteModeUseItemIndex;
            this.ios.legend.update();
        }
    };
    RadPieChart.prototype.updateChart = function () {
        if (this._loaded) {
            this.ios.update();
        }
    };
    RadPieChart.prototype.onLoaded = function () {
        _super.prototype.onLoaded.call(this);
        this._ios.delegate = this._delegate;
        this._loaded = true;
    };
    RadPieChart.prototype.onUnloaded = function () {
        this._ios.delegate = null;
        this._loaded = false;
    };
    RadPieChart.prototype.onSeriesChanged = function (data) {
        _super.prototype.onSeriesChanged.call(this, data);
        if (data.oldValue) {
            for (var i = 0; i < data.oldValue.length; ++i) {
                data.oldValue[i].owner = undefined;
            }
        }
        if (this.series) {
            for (var i = 0; i < this.series.length; ++i) {
                this.series[i].owner = this;
                if (this.series[i].ios) {
                    this.addSeries(this.series[i].ios);
                }
            }
        }
        this.updateChart();
    };
    RadPieChart.prototype.onSelectionModeChanged = function (data) {
        _super.prototype.onSelectionModeChanged.call(this, data);
        if (!this.ios) {
            return;
        }
        if (data.newValue) {
            if (commonModule.ChartSelectionMode.Single.toLowerCase() === data.newValue.toLowerCase()) {
                this.ios.selectionMode = TKChartSelectionMode.TKChartSelectionModeSingle;
            }
            else if (commonModule.ChartSelectionMode.Multiple.toLowerCase() === data.newValue.toLowerCase()) {
                this.ios.selectionMode = TKChartSelectionMode.TKChartSelectionModeMultiple;
            }
        }
        this.updateChart();
    };
    RadPieChart.prototype.onPalettesChanged = function (data) {
        var newPalettes = data.newValue;
        this.loadPalette(newPalettes);
        this.updateChart();
    };
    RadPieChart.prototype.loadPalette = function (newPalettes) {
        if (!this.ios || !this.series) {
            return;
        }
        if (newPalettes) {
            for (var i = 0; i < this.series.length; ++i) {
                var palettesForSeries = this.getPalettesForSeries(newPalettes, this.series[i]);
                if (palettesForSeries.length > 0) {
                    this.applyPalettesToSeries(palettesForSeries, this.series[i]);
                }
            }
        }
    };
    RadPieChart.prototype.getPalettesForSeries = function (source, series) {
        var palettes = [];
        for (var i = 0; i < source.length; i++) {
            var palette = source[i];
            if (palette.seriesName === series[commonModule.seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    };
    RadPieChart.prototype.applyPalettesToSeries = function (palette, series) {
        if (!series.ios) {
            return;
        }
        var selectionPalette, normalPalette;
        for (var i = 0; i < palette.length; ++i) {
            if (palette[i].seriesState && palette[i].seriesState.toLowerCase() === commonModule.PaletteEntryUseState.Selected.toLowerCase()) {
                selectionPalette = palette[i];
            }
            else {
                normalPalette = palette[i];
            }
        }
        this._chartPalette = (normalPalette) ? this.buildNativePaletteForSeries(normalPalette, series) : null;
        this.chartSelectionPalette = (selectionPalette) ? this.buildNativePaletteForSeries(selectionPalette, series) : null;
    };
    RadPieChart.prototype.buildNativePaletteForSeries = function (palette, series) {
        var seriesPalette = TKChartPalette.new();
        var paletteEntry;
        var currentPaletteEntry;
        for (var i = 0; i < palette.entries.length; ++i) {
            currentPaletteEntry = series.ios.style.palette.items[i % series.ios.style.palette.itemsCount];
            paletteEntry = palette.entries[i];
            var stroke = TKStroke.new();
            if (!isNaN(paletteEntry.strokeWidth)) {
                stroke.width = paletteEntry.strokeWidth;
            }
            else {
                stroke.width = (currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.width : 2;
            }
            if (paletteEntry.strokeColor) {
                stroke.color = (new color_1.Color(paletteEntry.strokeColor)).ios;
            }
            else {
                stroke.color = currentPaletteEntry.stroke ? currentPaletteEntry.stroke.color : (new color_1.Color("Black")).ios;
            }
            var solidFill = TKSolidFill.new();
            if (paletteEntry.fillColor) {
                solidFill.color = (new color_1.Color(paletteEntry.fillColor)).ios;
            }
            else {
                solidFill.color = currentPaletteEntry.fill ? currentPaletteEntry.fill.color : (new color_1.Color("Blue")).ios;
            }
            seriesPalette.addPaletteItem(TKChartPaletteItem.paletteItemWithStrokeAndFill(stroke, solidFill));
        }
        return seriesPalette;
    };
    return RadPieChart;
}(commonModule.RadPieChart));
exports.RadPieChart = RadPieChart;
var PieSeries = (function (_super) {
    __extends(PieSeries, _super);
    function PieSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(PieSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    return PieSeries;
}(commonModule.PieSeries));
exports.PieSeries = PieSeries;
var DonutSeries = (function (_super) {
    __extends(DonutSeries, _super);
    function DonutSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(DonutSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DonutSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.DonutSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    DonutSeries.prototype.onInnerRadiusFactorChanged = function (data) {
        this.initializer.onInnerRadiusFactorChanged(data, this);
    };
    return DonutSeries;
}(commonModule.DonutSeries));
exports.DonutSeries = DonutSeries;
/////////////////////******//////////////////////////////
var RadCartesianChart = (function (_super) {
    __extends(RadCartesianChart, _super);
    function RadCartesianChart() {
        _super.call(this);
        this._ios = TKChart.new();
        this._ios.selectionMode = TKChartSelectionMode.TKChartSelectionModeSingle;
        this._ios.allowAnimations = true;
        this._delegate = ChartDelegateImpl.new().initWithOwner(this);
        this._chartSelectionPalettesMap = new Map();
    }
    Object.defineProperty(RadCartesianChart.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    RadCartesianChart.prototype.onLoaded = function () {
        _super.prototype.onLoaded.call(this);
        this._ios.delegate = this._delegate;
        this._loaded = true;
    };
    RadCartesianChart.prototype.onUnloaded = function () {
        this._ios.delegate = null;
        this._loaded = false;
    };
    RadCartesianChart.prototype.updateChart = function () {
        if (this._loaded) {
            this.ios.update();
        }
    };
    RadCartesianChart.prototype.onSeriesChanged = function (data) {
        _super.prototype.onSeriesChanged.call(this, data);
        if (data.oldValue) {
            for (var i = 0; i < data.oldValue.length; ++i) {
                data.oldValue[i].owner = undefined;
            }
        }
        if (this.series) {
            for (var i = 0; i < this.series.length; ++i) {
                this.series[i].owner = this;
            }
        }
        this.loadChart();
    };
    RadCartesianChart.prototype.addSeries = function (newSeries) {
        this.loadChart();
    };
    RadCartesianChart.prototype.getAxixByID = function (axisID) {
        if (this.horizontalAxis && this.horizontalAxis.id === axisID) {
            return this.horizontalAxis;
        }
        if (this.verticalAxis && this.verticalAxis.id === axisID) {
            return this.verticalAxis;
        }
        if (this.series) {
            var axes = void 0;
            for (var i = 0; i < this.series.length; ++i) {
                axes = this.series[i].horizontalAxis;
                if (axes && axes.id === axisID) {
                    return axes;
                }
                axes = this.series[i].verticalAxis;
                if (axes && axes.id === axisID) {
                    return axes;
                }
            }
        }
        return null;
    };
    RadCartesianChart.prototype.onAnnotationsChanged = function (data) {
        _super.prototype.onAnnotationsChanged.call(this, data);
        if (data.oldValue) {
            for (var i = 0; i < data.oldValue.length; ++i) {
                data.oldValue[i].owner = undefined;
            }
        }
        if (this.annotations) {
            for (var i = 0; i < this.annotations.length; ++i) {
                this.annotations[i].owner = this;
            }
        }
        this.loadChart();
    };
    RadCartesianChart.prototype.onHorizontalAxisChanged = function (data) {
        _super.prototype.onHorizontalAxisChanged.call(this, data);
        //since label alignment requires info about horizontal or vertical the axis is, we set appropriate values here
        var theAxis = data.newValue;
        if (theAxis && theAxis.labelLayoutMode) {
            if (theAxis.labelLayoutMode.toLowerCase() === commonModule.AxisLabelLayoutMode.Inner.toLowerCase()) {
                theAxis.ios.style.labelStyle.textAlignment = TKChartAxisLabelAlignment.TKChartAxisLabelAlignmentTop;
            }
            else {
                theAxis.ios.style.labelStyle.textAlignment = TKChartAxisLabelAlignment.TKChartAxisLabelAlignmentBottom;
            }
        }
    };
    RadCartesianChart.prototype.onVerticalAxisChanged = function (data) {
        _super.prototype.onVerticalAxisChanged.call(this, data);
        var theAxis = data.newValue;
        if (theAxis && theAxis.labelLayoutMode) {
            if (theAxis.labelLayoutMode.toLowerCase() === commonModule.AxisLabelLayoutMode.Inner.toLowerCase()) {
                theAxis.ios.style.labelStyle.textAlignment = TKChartAxisLabelAlignment.TKChartAxisLabelAlignmentRight;
            }
            else {
                theAxis.ios.style.labelStyle.textAlignment = TKChartAxisLabelAlignment.TKChartAxisLabelAlignmentLeft;
            }
        }
    };
    RadCartesianChart.prototype.loadChart = function () {
        if (this.ios && this.series) {
            this.ios.removeAllData();
            if (this.horizontalAxis) {
                if (!this.horizontalAxis.verticalLocation) {
                    this.horizontalAxis.ios.position = TKChartAxisPosition.TKChartAxisPositionBottom;
                }
                this.ios.addAxis(this.horizontalAxis.ios);
                this.ios.xAxis = this.horizontalAxis.ios;
                this.horizontalAxis.owner = this;
            }
            if (this.verticalAxis) {
                if (!this.verticalAxis.horizontalLocation) {
                    this.verticalAxis.ios.position = TKChartAxisPosition.TKChartAxisPositionLeft;
                }
                this.ios.addAxis(this.verticalAxis.ios);
                this.ios.yAxis = this.verticalAxis.ios;
                this.verticalAxis.owner = this;
            }
            for (var i = 0; i < this.series.length; ++i) {
                if (this.series[i].ios) {
                    var axis = this.series[i].horizontalAxis;
                    if (axis) {
                        if (!this.ios.xAxis) {
                            this.ios.xAxis = axis.ios;
                        }
                        this.ios.addAxis(axis.ios);
                        axis.owner = this;
                    }
                    axis = this.series[i].verticalAxis;
                    if (axis) {
                        if (!this.ios.yAxis) {
                            this.ios.yAxis = axis.ios;
                        }
                        this.ios.addAxis(axis.ios);
                        axis.owner = this;
                    }
                    this.ios.addSeries(this.series[i].ios);
                }
            }
            if (this.horizontalZoom || this.verticalZoom) {
                this.updateZoom();
            }
            if (this.palettes) {
                for (var i = 0; i < this.series.length; ++i) {
                    if (this.series[i].ios) {
                        this.series[i].ios.tag = i; //tag will keep the number of series in current collection
                    }
                }
                this.loadPalette(this.palettes);
            }
            if (this.grid) {
                this.grid.applyGridStyle();
            }
            if (this.annotations) {
                for (var i = 0; i < this.annotations.length; ++i) {
                    if (this.annotations[i].ios && this.annotations[i].axisId) {
                        this.ios.addAnnotation(this.annotations[i].ios);
                    }
                }
            }
            this.ios.update();
        }
    };
    RadCartesianChart.prototype.updateZoom = function () {
        if (!this.horizontalZoom && !this.verticalZoom) {
            return;
        }
        if (this.horizontalZoom && this.horizontalAxis) {
            this.horizontalAxis.ios.zoom = this.horizontalZoom;
        }
        if (this.verticalZoom && this.verticalAxis) {
            this.verticalAxis.ios.zoom = this.verticalZoom;
        }
        if (this.series) {
            for (var i = 0; i < this.series.length; ++i) {
                if (this.series[i].ios) {
                    if (this.series[i].horizontalAxis && this.horizontalZoom) {
                        this.series[i].horizontalAxis.ios.zoom = this.horizontalZoom;
                    }
                    if (this.series[i].verticalAxis && this.verticalZoom) {
                        this.series[i].verticalAxis.ios.zoom = this.verticalZoom;
                    }
                }
            }
        }
    };
    RadCartesianChart.prototype.onGridChanged = function (data) {
        if (data.newValue instanceof RadCartesianChartGrid) {
            data.newValue.owner = this;
        }
    };
    RadCartesianChart.prototype.onPalettesChanged = function (data) {
        var newPalettes = data.newValue;
        this.loadPalette(newPalettes);
    };
    RadCartesianChart.prototype.loadPalette = function (palettes) {
        if (!this.ios || !this.series) {
            return;
        }
        if (this.palettes) {
            for (var i = 0; i < this.series.length; ++i) {
                var entriesForSeries = this.getPalettesForSeries(palettes, this.series[i]);
                if (entriesForSeries.length > 0) {
                    this.applyPalettesToSeries(entriesForSeries, this.series[i]);
                }
            }
        }
    };
    RadCartesianChart.prototype.getPalettesForSeries = function (source, series) {
        var palettes = [];
        for (var i = 0; i < source.length; i++) {
            var palette = source[i];
            if (palette.seriesName === series[commonModule.seriesName]) {
                palettes.push(palette);
            }
        }
        return palettes;
    };
    RadCartesianChart.prototype.applyPalettesToSeries = function (palettes, series) {
        if (!series.ios) {
            return;
        }
        var selectionPalette, normalPalette;
        for (var i = 0; i < palettes.length; ++i) {
            if (palettes[i].seriesState && palettes[i].seriesState.toLowerCase() === commonModule.PaletteEntryUseState.Selected.toLowerCase()) {
                selectionPalette = palettes[i];
            }
            else {
                normalPalette = palettes[i];
            }
        }
        var normal = (normalPalette) ? this.buildNativePaletteForSeries(normalPalette, series) : null;
        if (normal) {
            this.optimizePaletteItemsForSeries(normal, series);
            series.ios.style.palette = normal;
        }
        var tmp = (selectionPalette) ? this._chartSelectionPalettesMap.get(selectionPalette.seriesName) : null;
        if (!tmp) {
            var selection = (selectionPalette) ? this.buildNativePaletteForSeries(selectionPalette, series) : null;
            if (selection) {
                this._chartSelectionPalettesMap.set(selectionPalette.seriesName, selection);
            }
        }
    };
    RadCartesianChart.prototype.buildNativePaletteForSeries = function (palette, series) {
        var seriesPalette = TKChartPalette.new();
        var paletteEntry;
        var currentPaletteEntry;
        for (var i = 0; i < palette.entries.length; ++i) {
            currentPaletteEntry = series.ios.style.palette.items.objectAtIndex(i % series.ios.style.palette.itemsCount);
            paletteEntry = palette.entries[i];
            var stroke = TKStroke.new();
            if (!isNaN(paletteEntry.strokeWidth)) {
                stroke.width = paletteEntry.strokeWidth;
            }
            else {
                stroke.width = (currentPaletteEntry.stroke) ? currentPaletteEntry.stroke.width : 2;
            }
            if (paletteEntry.strokeColor) {
                stroke.color = (new color_1.Color(paletteEntry.strokeColor)).ios;
            }
            else {
                stroke.color = currentPaletteEntry.stroke ? currentPaletteEntry.stroke.color : (new color_1.Color("Black")).ios;
            }
            var solidFill = TKSolidFill.new();
            if (paletteEntry.fillColor) {
                solidFill.color = (new color_1.Color(paletteEntry.fillColor)).ios;
            }
            else {
                solidFill.color = currentPaletteEntry.fill ? currentPaletteEntry.fill.color : (new color_1.Color("Blue")).ios;
            }
            seriesPalette.addPaletteItem(TKChartPaletteItem.paletteItemWithStrokeAndFill(stroke, solidFill));
        }
        return seriesPalette;
    };
    /** Removes all custom palette items that should not be used for this series in current sequence of series.
     * NOTE: This is required since the order of series with same seriesName in chart could lead to usage of the same palette items.
     *       We need to ensure that palette items will be used according to the sequence of series in group of same name.
     * @param palette - the native palette instance
     * @param series - the series that palette will be used for
     */
    RadCartesianChart.prototype.optimizePaletteItemsForSeries = function (palette, series) {
        if (!palette) {
            return;
        }
        var itemIndex = 0;
        for (var i = 0; i < this.series.length; ++i) {
            if ((this.series[i].seriesName === series.seriesName) && (this.series[i].ios.index < series.ios.index)) {
                itemIndex++;
            }
        }
        var item = palette.items[itemIndex % palette.items.count];
        palette.clearPalette();
        palette.addPaletteItem(item);
    };
    /** Finds the corresponding palette item for selected series
     * @param nativeIndex - the index of series in native control
     * @param seriesIndex - the index of series in {N} chart's series collection
     */
    RadCartesianChart.prototype.getSelectionPaletteItemWithIndexForSeries = function (nativeIndex, seriesIndex) {
        var item = null;
        var palette = (this.series[seriesIndex]) ? this._chartSelectionPalettesMap.get(this.series[seriesIndex].seriesName) : null;
        var groupName = this.series[seriesIndex].seriesName;
        if (palette) {
            //find the series' consequent number in group of series with the same seriesName value
            var itemIndex = 0;
            var seriesName = void 0;
            for (var i = 0; i < this.series.length; ++i) {
                seriesName = this.series[i].seriesName;
                if (seriesName === groupName && this.series[i].ios.index < nativeIndex) {
                    itemIndex++;
                }
            }
            item = palette.items[itemIndex % palette.items.count];
        }
        return item;
    };
    RadCartesianChart.prototype.onSelectionModeChanged = function (data) {
        _super.prototype.onSelectionModeChanged.call(this, data);
        if (!this.ios) {
            return;
        }
        if (data.newValue) {
            if (commonModule.ChartSelectionMode.Single === data.newValue) {
                this.ios.selectionMode = TKChartSelectionMode.TKChartSelectionModeSingle;
            }
            else if (commonModule.ChartSelectionMode.Multiple === data.newValue) {
                this.ios.selectionMode = TKChartSelectionMode.TKChartSelectionModeMultiple;
            }
        }
    };
    RadCartesianChart.prototype.onHorizontalZoomChanged = function (data) {
        if (!this.ios) {
            return;
        }
        if (!isNaN(+data.newValue) && data.newValue > 1) {
            this.updateZoom();
        }
        else {
            console.log("WARNING: Horizontal zoom must be a number greater or equal to 1");
        }
    };
    RadCartesianChart.prototype.onVerticalZoomChanged = function (data) {
        if (!this.ios) {
            return;
        }
        if (!isNaN(+data.newValue) && data.newValue > 1) {
            this.updateZoom();
        }
        else {
            console.log("WARNING: Vertical zoom must be a number greater or equal to 1");
        }
    };
    RadCartesianChart.prototype.onTrackballChanged = function (data) {
        if (data.newValue && (data.newValue instanceof commonModule.Trackball)) {
            this.ios.allowTrackball = true;
            this.trackball.ios = this.ios.trackball;
        }
        else {
            this.ios.allowTrackball = false;
        }
    };
    return RadCartesianChart;
}(commonModule.RadCartesianChart));
exports.RadCartesianChart = RadCartesianChart;
////////////////////////////////////////////////////////////////////////
// LinearAxis
////////////////////////////////////////////////////////////////////////
var LinearAxis = (function (_super) {
    __extends(LinearAxis, _super);
    function LinearAxis() {
        _super.call(this);
        this._ios = TKChartNumericAxis.new();
        this._ios.offset = 0;
        this._ios.baseline = 0;
    }
    Object.defineProperty(LinearAxis.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    LinearAxis.prototype.onMajorStepChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            this.ios.majorTickInterval = data.newValue;
            this.update();
        }
    };
    LinearAxis.prototype.onMinimumChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            if (this.ios.range) {
                this.ios.range.minimum = data.newValue;
            }
            else {
                this.ios.range = TKRange.rangeWithMinimumAndMaximum(data.newValue, data.newValue * 2);
            }
            this.update();
        }
    };
    LinearAxis.prototype.onMaximumChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            if (this.ios.range) {
                this.ios.range.maximum = data.newValue;
            }
            else {
                this.ios.range = TKRange.rangeWithMinimumAndMaximum(data.newValue / 2, data.newValue);
            }
            this.update();
        }
    };
    return LinearAxis;
}(commonModule.LinearAxis));
exports.LinearAxis = LinearAxis;
////////////////////////////////////////////////////////////////////////
// CategoricalAxis
////////////////////////////////////////////////////////////////////////
var CategoricalAxis = (function (_super) {
    __extends(CategoricalAxis, _super);
    function CategoricalAxis() {
        _super.call(this);
        this._ios = TKChartCategoryAxis.alloc().init();
        this._ios.offset = 0;
        this._ios.baseline = 0;
    }
    Object.defineProperty(CategoricalAxis.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    return CategoricalAxis;
}(commonModule.CategoricalAxis));
exports.CategoricalAxis = CategoricalAxis;
////////////////////////////////////////////////////////////////////////
// DateTimeContinuousAxis
////////////////////////////////////////////////////////////////////////
var DateTimeContinuousAxis = (function (_super) {
    __extends(DateTimeContinuousAxis, _super);
    function DateTimeContinuousAxis() {
        _super.call(this);
        this._ios = TKChartDateTimeAxis.new();
        this._ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitMonths;
        this._ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitMonths;
        this._ios.majorTickInterval = 1;
        this._ios.setPlotMode(TKChartAxisPlotMode.TKChartAxisPlotModeBetweenTicks);
    }
    Object.defineProperty(DateTimeContinuousAxis.prototype, "dateFormatter", {
        get: function () {
            if (this._dateFormatter) {
                return this._dateFormatter;
            }
            this._dateFormatter = NSDateFormatter.alloc().init();
            this._dateFormatter.dateFormat = "dd/MM/yyyy"; //note: currently only this format is supported in xml
            return this._dateFormatter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimeContinuousAxis.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    DateTimeContinuousAxis.prototype.onMinimumChanged = function (data) {
        if (data.newValue && this.maximum) {
            this.updateRange();
        }
    };
    DateTimeContinuousAxis.prototype.onMaximumChanged = function (data) {
        if (data.newValue && this.minimum) {
            this.updateRange();
        }
    };
    DateTimeContinuousAxis.prototype.updateRange = function () {
        var minDate = this.minimum;
        if (typeof this.minimum === "string") {
            minDate = this.dateFormatter.dateFromString(this.minimum);
        }
        var maxDate = this.maximum;
        if (typeof this.maximum === "string") {
            maxDate = this.dateFormatter.dateFromString(this.maximum);
        }
        this.ios.range = TKRange.rangeWithMinimumAndMaximum(minDate, maxDate);
        this.update();
    };
    DateTimeContinuousAxis.prototype.onPlotModeChanged = function (data) {
        if (data.newValue) {
            switch (data.newValue.toLowerCase()) {
                case commonModule.AxisPlotMode.BetweenTicks.toLowerCase():
                    this.ios.setPlotMode(TKChartAxisPlotMode.TKChartAxisPlotModeBetweenTicks);
                    break;
                case commonModule.AxisPlotMode.OnTicks.toLowerCase():
                    this.ios.setPlotMode(TKChartAxisPlotMode.TKChartAxisPlotModeOnTicks);
                    break;
                default:
                    console.log("WARNING: Unsupported plot mode set: " + data.newValue);
            }
            this.update();
        }
    };
    DateTimeContinuousAxis.prototype.onDateFormatChanged = function (data) {
        if (data.newValue) {
            var dateFormatter = NSDateFormatter.alloc().init();
            dateFormatter.dateFormat = data.newValue;
            this.ios.labelFormatter = dateFormatter;
            this.update();
        }
    };
    DateTimeContinuousAxis.prototype.onMajorStepChanged = function (data) {
        if (data.newValue) {
            //todo: consider minorTickIntervalUnit property value. It is used for financial series and determins the width of candlesticks.
            switch (data.newValue.toLowerCase()) {
                case commonModule.DateTimeComponent.Second.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitSeconds;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitSeconds;
                    break;
                case commonModule.DateTimeComponent.Minute.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitMinutes;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitMinutes;
                    break;
                case commonModule.DateTimeComponent.Hour.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitHours;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitHours;
                    break;
                case commonModule.DateTimeComponent.Day.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitDays;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitDays;
                    break;
                case commonModule.DateTimeComponent.Week.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitWeeks;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitWeeks;
                    break;
                case commonModule.DateTimeComponent.Month.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitMonths;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitMonths;
                    break;
                case commonModule.DateTimeComponent.Year.toLowerCase():
                    this.ios.majorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitYears;
                    this.ios.minorTickIntervalUnit = TKChartDateTimeAxisIntervalUnit.TKChartDateTimeAxisIntervalUnitYears;
                    break;
            }
            this.update();
        }
    };
    return DateTimeContinuousAxis;
}(commonModule.DateTimeContinuousAxis));
exports.DateTimeContinuousAxis = DateTimeContinuousAxis;
////////////////////////////////////////////////////////////////////////
// DateTimeCategoricalAxis
////////////////////////////////////////////////////////////////////////
var DateTimeCategoricalAxis = (function (_super) {
    __extends(DateTimeCategoricalAxis, _super);
    function DateTimeCategoricalAxis() {
        _super.call(this);
        this._ios = TKChartDateTimeCategoryAxis.new();
    }
    Object.defineProperty(DateTimeCategoricalAxis.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    DateTimeCategoricalAxis.prototype.onDateFormatChanged = function (data) {
        if (data.newValue) {
            var dateFormatter = NSDateFormatter.alloc().init();
            dateFormatter.dateFormat = data.newValue;
            this.ios.labelFormatter = dateFormatter;
            this.update();
        }
    };
    DateTimeCategoricalAxis.prototype.onDateTimeComponentChanged = function (data) {
        if (data.newValue) {
            switch (data.newValue.toLowerCase()) {
                case commonModule.DateTimeComponent.Second.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitSecond;
                    break;
                case commonModule.DateTimeComponent.Minute.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitMinute;
                    break;
                case commonModule.DateTimeComponent.Hour.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitHour;
                    break;
                case commonModule.DateTimeComponent.Day.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitDay;
                    break;
                case commonModule.DateTimeComponent.Week.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitWeekOfMonth;
                    break;
                case commonModule.DateTimeComponent.Month.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitMonth;
                    break;
                case commonModule.DateTimeComponent.Year.toLowerCase():
                    this.ios.dateComponent = NSCalendarUnitYear;
                    break;
            }
            this.update();
        }
    };
    return DateTimeCategoricalAxis;
}(commonModule.DateTimeCategoricalAxis));
exports.DateTimeCategoricalAxis = DateTimeCategoricalAxis;
////////////////////////////////////////////////////////////////////////
// LogarithmicAxis
////////////////////////////////////////////////////////////////////////
var LogarithmicAxis = (function (_super) {
    __extends(LogarithmicAxis, _super);
    function LogarithmicAxis() {
        _super.call(this);
        this._ios = TKChartLogarithmicAxis.new();
    }
    Object.defineProperty(LogarithmicAxis.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    LogarithmicAxis.prototype.onExponentStepChanged = function (data) {
        if (!isNaN(+data.newValue) && data.newValue > 0) {
            this._ios.exponentStep = data.newValue;
            this.update();
        }
    };
    LogarithmicAxis.prototype.onLogarithmBaseChanged = function (data) {
        if (!isNaN(data.newValue)) {
            this._ios.logarithmBase = data.newValue;
            this.update();
        }
    };
    return LogarithmicAxis;
}(commonModule.LogarithmicAxis));
exports.LogarithmicAxis = LogarithmicAxis;
////////////////////////////////////////////////////////////////////////
// RadCartesianChartGrid
////////////////////////////////////////////////////////////////////////
//NOTE: The workflow that uses exclusively created TKChartGridStyle instance (this.ios) is dummy, but needed.
//We faced with a bug that grid styling has some statics and if we set properties directly to this.owner.ios.gridStyle
//in view with multiple charts the grid of all of them have the same horizontal/vertial lines.
//The native code should be debug and statics removed.
////////////////////////////////////////////////////////////////////////
var RadCartesianChartGrid = (function (_super) {
    __extends(RadCartesianChartGrid, _super);
    function RadCartesianChartGrid() {
        _super.call(this);
        this._ios = TKChartGridStyle.new();
        this._ios.drawOrder = TKChartGridDrawMode.TKChartGridDrawModeVerticalFirst;
    }
    Object.defineProperty(RadCartesianChartGrid.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    RadCartesianChartGrid.prototype.onOwnerChanged = function () {
        this.applyGridStyle();
    };
    RadCartesianChartGrid.prototype.applyGridStyle = function () {
        if (!this.owner) {
            return;
        }
        var style = this.owner.ios.gridStyle;
        style.drawOrder = this.ios.drawOrder;
        style.verticalLineStroke = this.ios.verticalLineStroke;
        ;
        style.verticalLineAlternateStroke = this.ios.verticalLineAlternateStroke;
        style.verticalLinesHidden = this.ios.verticalLinesHidden;
        style.verticalFill = this.ios.verticalFill;
        style.verticalAlternateFill = this.ios.verticalAlternateFill;
        style.horizontalLineStroke = this.ios.horizontalLineStroke;
        style.horizontalLineAlternateStroke = this.ios.horizontalLineAlternateStroke;
        style.horizontalFill = this.ios.horizontalFill;
        style.horizontalAlternateFill = this.ios.horizontalAlternateFill;
        style.horizontalLinesHidden = this.ios.horizontalLinesHidden;
        this.owner.updateChart();
    };
    RadCartesianChartGrid.prototype.updateGridStyle = function () {
        if (this.verticalLinesVisible != undefined)
            this.ios.verticalLinesHidden = (this.verticalLinesVisible) ? false : true;
        if (this.horizontalLinesVisible != undefined)
            this.ios.horizontalLinesHidden = (this.horizontalLinesVisible) ? false : true;
        if (this.verticalStripLineColor != undefined)
            this.updateVerticalFill(this.verticalStripLineColor);
        if (this.horizontalStripLineColor != undefined)
            this.updateHorizontalFill(this.horizontalStripLineColor);
        if (this.verticalStrokeColor) {
            var colors = this.verticalStrokeColor.split(',');
            this.ios.verticalLineStroke.color = (new color_1.Color(colors[0].trim())).ios;
            this.ios.verticalLineAlternateStroke.color = (colors[1] == undefined) ? (new color_1.Color(colors[0].trim())).ios : (new color_1.Color(colors[1].trim())).ios;
        }
        if (this.horizontalStrokeColor) {
            var colors = this.horizontalStrokeColor.split(',');
            this.ios.horizontalLineStroke.color = (new color_1.Color(colors[0].trim())).ios;
            this.ios.horizontalLineAlternateStroke.color = (colors[1] == undefined) ? (new color_1.Color(colors[0].trim())).ios : (new color_1.Color(colors[1].trim())).ios;
        }
        this.ios.verticalLineStroke.width = this.verticalStrokeWidth;
        this.ios.verticalLineAlternateStroke.width = this.verticalStrokeWidth;
        this.ios.horizontalLineStroke.width = this.horizontalStrokeWidth;
        this.ios.horizontalLineAlternateStroke.width = this.horizontalStrokeWidth;
        this.applyGridStyle();
    };
    RadCartesianChartGrid.prototype.updateHorizontalFill = function (color) {
        if (!color || !this.horizontalStripLinesVisible) {
            this.ios.horizontalFill = null;
            this.ios.horizontalAlternateFill = null;
        }
        else {
            var colors = color.split(',');
            // This is a workaround for the fact that in iOS when there is an alternate fill, it is applied first.
            if (colors[1] == undefined) {
                this.ios.horizontalFill = TKSolidFill.solidFillWithColor((new color_1.Color(colors[0].trim())).ios);
                this.ios.horizontalAlternateFill = null;
            }
            else {
                this.ios.horizontalAlternateFill = TKSolidFill.solidFillWithColor((new color_1.Color(colors[0].trim())).ios);
                this.ios.horizontalFill = TKSolidFill.solidFillWithColor((new color_1.Color(colors[1].trim())).ios);
            }
        }
        this.applyGridStyle();
    };
    RadCartesianChartGrid.prototype.updateVerticalFill = function (color) {
        if (!color || !this.verticalStripLinesVisible) {
            this.ios.verticalFill = null;
            this.ios.verticalAlternateFill = null;
        }
        else {
            var colors = color.split(',');
            // This is a workaround for the fact that in iOS when there is an alternate fill, it is applied first.
            if (colors[1] == undefined) {
                this.ios.verticalFill = TKSolidFill.solidFillWithColor((new color_1.Color(colors[0].trim())).ios);
                this.ios.verticalAlternateFill = null;
            }
            else {
                this.ios.verticalAlternateFill = TKSolidFill.solidFillWithColor((new color_1.Color(colors[0].trim())).ios);
                this.ios.verticalFill = TKSolidFill.solidFillWithColor((new color_1.Color(colors[1].trim())).ios);
            }
        }
        this.applyGridStyle();
    };
    RadCartesianChartGrid.prototype.onVerticalLinesVisibleChanged = function (data) {
        this.ios.verticalLinesHidden = (data.newValue) ? false : true;
        this.applyGridStyle();
    };
    RadCartesianChartGrid.prototype.onHorizontalLinesVisibleChanged = function (data) {
        this.ios.horizontalLinesHidden = (data.newValue) ? false : true;
        this.applyGridStyle();
    };
    RadCartesianChartGrid.prototype.onHorizontalStripLinesVisibleChanged = function (data) {
        this.updateHorizontalFill((data.newValue) ? this.horizontalStripLineColor : null);
    };
    RadCartesianChartGrid.prototype.onVerticalStripLinesVisibleChanged = function (data) {
        this.updateVerticalFill((data.newValue) ? this.verticalStripLineColor : null);
    };
    RadCartesianChartGrid.prototype.onVerticalStrokeColorChanged = function (data) {
        if (data.newValue) {
            var colors = data.newValue.split(',');
            this.ios.verticalLineStroke.color = (new color_1.Color(colors[0].trim())).ios;
            this.ios.verticalLineAlternateStroke.color = (colors[1] == undefined) ? (new color_1.Color(colors[0].trim())).ios : (new color_1.Color(colors[1].trim())).ios;
            this.applyGridStyle();
        }
    };
    RadCartesianChartGrid.prototype.onHorizontalStrokeColorChanged = function (data) {
        if (data.newValue) {
            var colors = data.newValue.split(',');
            this.ios.horizontalLineStroke.color = (new color_1.Color(colors[0].trim())).ios;
            this.ios.horizontalLineAlternateStroke.color = (colors[1] == undefined) ? (new color_1.Color(colors[0].trim())).ios : (new color_1.Color(colors[1].trim())).ios;
            this.applyGridStyle();
        }
    };
    RadCartesianChartGrid.prototype.onHorizontalStrokeWidthChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            this.ios.horizontalLineStroke.width = data.newValue;
            this.ios.horizontalLineAlternateStroke.width = data.newValue;
            this.applyGridStyle();
        }
    };
    RadCartesianChartGrid.prototype.onVerticalStrokeWidthChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            this.ios.verticalLineStroke.width = data.newValue;
            this.ios.verticalLineAlternateStroke.width = data.newValue;
            this.applyGridStyle();
        }
    };
    RadCartesianChartGrid.prototype.onVerticalStripLineColorChanged = function (data) {
        this.updateVerticalFill(data.newValue);
    };
    RadCartesianChartGrid.prototype.onHorizontalStripLineColorChanged = function (data) {
        this.updateHorizontalFill(data.newValue);
    };
    return RadCartesianChartGrid;
}(commonModule.RadCartesianChartGrid));
exports.RadCartesianChartGrid = RadCartesianChartGrid;
////////////////////////////////////////////////////////////////////////
// RadLegendView
////////////////////////////////////////////////////////////////////////
var RadLegendView = (function (_super) {
    __extends(RadLegendView, _super);
    function RadLegendView() {
        _super.apply(this, arguments);
    }
    RadLegendView.prototype.onPositionChanged = function (data) {
        this.updateLegendView(this._chart);
    };
    RadLegendView.prototype.onVerticalOffsetChanged = function (data) {
        this.updateLegendView(this._chart);
    };
    RadLegendView.prototype.onHorizontalOffsetChanged = function (data) {
        this.updateLegendView(this._chart);
    };
    RadLegendView.prototype.onOffsetOriginChanged = function (data) {
        this.updateLegendView(this._chart);
    };
    RadLegendView.prototype.onTitleChanged = function (data) {
        this.updateLegendView(this._chart);
    };
    RadLegendView.prototype.updateLegendPosition = function (chartView) {
        if (!this.position) {
            return;
        }
        switch (this.position.toLowerCase()) {
            case commonModule.ChartLegendPosition.Left.toLowerCase():
                chartView.ios.legend.style.position = TKChartLegendPosition.TKChartLegendPositionLeft;
                break;
            case commonModule.ChartLegendPosition.Right.toLowerCase():
                chartView.ios.legend.style.position = TKChartLegendPosition.TKChartLegendPositionRight;
                break;
            case commonModule.ChartLegendPosition.Top.toLowerCase():
                chartView.ios.legend.style.position = TKChartLegendPosition.TKChartLegendPositionTop;
                break;
            case commonModule.ChartLegendPosition.Bottom.toLowerCase():
                chartView.ios.legend.style.position = TKChartLegendPosition.TKChartLegendPositionBottom;
                break;
            case commonModule.ChartLegendPosition.Floating.toLowerCase():
                chartView.ios.legend.style.position = TKChartLegendPosition.TKChartLegendPositionFloating;
                break;
        }
        if (this.position === commonModule.ChartLegendPosition.Floating) {
            switch (this.offsetOrigin.toLowerCase()) {
                case commonModule.ChartLegendOffsetOrigin.TopLeft.toLowerCase():
                    chartView.ios.legend.style.offsetOrigin = TKChartLegendOffsetOrigin.TKChartLegendOffsetOriginTopLeft;
                    break;
                case commonModule.ChartLegendOffsetOrigin.TopRight.toLowerCase():
                    chartView.ios.legend.style.offsetOrigin = TKChartLegendOffsetOrigin.TKChartLegendOffsetOriginTopRight;
                    break;
                case commonModule.ChartLegendOffsetOrigin.BottomLeft.toLowerCase():
                    chartView.ios.legend.style.offsetOrigin = TKChartLegendOffsetOrigin.TKChartLegendOffsetOriginBottomLeft;
                    break;
                case commonModule.ChartLegendOffsetOrigin.BottomRight.toLowerCase():
                    chartView.ios.legend.style.offsetOrigin = TKChartLegendOffsetOrigin.TKChartLegendOffsetOriginBottomRight;
                    break;
                default:
                    chartView.ios.legend.style.offsetOrigin = TKChartLegendOffsetOrigin.TKChartLegendOffsetOriginTopLeft;
            }
            chartView.ios.legend.style.offset = {
                horizontal: (isNaN(this.horizontalOffset)) ? 0 : this.horizontalOffset,
                vertical: (isNaN(this.verticalOffset)) ? 0 : this.verticalOffset
            };
        }
    };
    RadLegendView.prototype.updateLegendView = function (chartView) {
        if (!(chartView)) {
            return;
        }
        if (!(chartView instanceof commonModule.RadChartBase)) {
            return;
        }
        if (!this._chart) {
            this._chart = chartView;
        }
        chartView.ios.legend.hidden = false;
        if (this.position) {
            this.updateLegendPosition(chartView);
        }
        if (this.title) {
            chartView.ios.legend.titleLabel.text = this.title;
            chartView.ios.legend.showTitle = true;
        }
        chartView.updateChart();
    };
    return RadLegendView;
}(commonModule.RadLegendView));
exports.RadLegendView = RadLegendView;
////////////////////////////////////////////////////////////////////////
// BarSeries
////////////////////////////////////////////////////////////////////////
var BarSeries = (function (_super) {
    __extends(BarSeries, _super);
    function BarSeries() {
        _super.call(this);
    }
    Object.defineProperty(BarSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    return BarSeries;
}(commonModule.BarSeries));
exports.BarSeries = BarSeries;
////////////////////////////////////////////////////////////////////////
// RangeBarSeries
////////////////////////////////////////////////////////////////////////
var RangeBarSeries = (function (_super) {
    __extends(RangeBarSeries, _super);
    function RangeBarSeries() {
        _super.call(this);
    }
    Object.defineProperty(RangeBarSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.RangeBarSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RangeBarSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    RangeBarSeries.prototype.onHighPropertyNameChanged = function (data) {
        this.initializer.onHighPropertyNameChanged(data, this);
    };
    RangeBarSeries.prototype.onLowPropertyNameChanged = function (data) {
        this.initializer.onLowPropertyNameChanged(data, this);
    };
    RangeBarSeries.prototype.onValuePropertyChanged = function (data) {
        console.log("WARNING: Range bar series doesn't use valueProperty property.");
    };
    return RangeBarSeries;
}(commonModule.RangeBarSeries));
exports.RangeBarSeries = RangeBarSeries;
////////////////////////////////////////////////////////////////////////
// LineSeries
////////////////////////////////////////////////////////////////////////
var LineSeries = (function (_super) {
    __extends(LineSeries, _super);
    function LineSeries() {
        _super.call(this);
    }
    Object.defineProperty(LineSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.LineSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    return LineSeries;
}(commonModule.CategoricalSeries));
exports.LineSeries = LineSeries;
var SplineSeries = (function (_super) {
    __extends(SplineSeries, _super);
    function SplineSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(SplineSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.SplineSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    return SplineSeries;
}(LineSeries));
exports.SplineSeries = SplineSeries;
var AreaSeries = (function (_super) {
    __extends(AreaSeries, _super);
    function AreaSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(AreaSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.AreaSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    return AreaSeries;
}(LineSeries));
exports.AreaSeries = AreaSeries;
var SplineAreaSeries = (function (_super) {
    __extends(SplineAreaSeries, _super);
    function SplineAreaSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(SplineAreaSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.SplineAreaSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    return SplineAreaSeries;
}(LineSeries));
exports.SplineAreaSeries = SplineAreaSeries;
var BubbleSeries = (function (_super) {
    __extends(BubbleSeries, _super);
    function BubbleSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(BubbleSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BubbleSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.BubbleSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    BubbleSeries.prototype.onBubbleScaleChanged = function (data) {
        this.initializer.onBubbleScalePropertyChanged(data, this);
    };
    BubbleSeries.prototype.onBubbleSizePropertyChanged = function (data) {
        this.initializer.onBubbleSizePropertyChanged(data, this);
    };
    return BubbleSeries;
}(commonModule.BubbleSeries));
exports.BubbleSeries = BubbleSeries;
var ScatterSeries = (function (_super) {
    __extends(ScatterSeries, _super);
    function ScatterSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(ScatterSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    return ScatterSeries;
}(commonModule.ScatterSeries));
exports.ScatterSeries = ScatterSeries;
var ScatterBubbleSeries = (function (_super) {
    __extends(ScatterBubbleSeries, _super);
    function ScatterBubbleSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(ScatterBubbleSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    return ScatterBubbleSeries;
}(commonModule.ScatterBubbleSeries));
exports.ScatterBubbleSeries = ScatterBubbleSeries;
var OhlcSeries = (function (_super) {
    __extends(OhlcSeries, _super);
    function OhlcSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(OhlcSeries.prototype, "ios", {
        get: function () {
            return this._series;
        },
        set: function (value) {
            this._series = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OhlcSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.OhlcSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    OhlcSeries.prototype.onHighPropertyNameChanged = function (data) {
        this.initializer.onHighPropertyNameChanged(data, this);
    };
    OhlcSeries.prototype.onLowPropertyNameChanged = function (data) {
        this.initializer.onLowPropertyNameChanged(data, this);
    };
    OhlcSeries.prototype.onOpenPropertyNameChanged = function (data) {
        this.initializer.onOpenPropertyNameChanged(data, this);
    };
    OhlcSeries.prototype.onClosePropertyNameChanged = function (data) {
        this.initializer.onClosePropertyNameChanged(data, this);
    };
    OhlcSeries.prototype.onValuePropertyChanged = function (data) {
        console.log("WARNING: OHLC series doesn't use valueProperty property.");
    };
    return OhlcSeries;
}(commonModule.OhlcSeries));
exports.OhlcSeries = OhlcSeries;
var CandlestickSeries = (function (_super) {
    __extends(CandlestickSeries, _super);
    function CandlestickSeries() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(CandlestickSeries.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeries.prototype, "initializer", {
        get: function () {
            if (!this._initializer) {
                this._initializer = new initializersImpl.CandlestickSeriesValueMapper();
            }
            return this._initializer;
        },
        enumerable: true,
        configurable: true
    });
    return CandlestickSeries;
}(OhlcSeries));
exports.CandlestickSeries = CandlestickSeries;
//////////////////////////////////////////////////////////
var ChartGridLineAnnotation = (function (_super) {
    __extends(ChartGridLineAnnotation, _super);
    function ChartGridLineAnnotation() {
        _super.call(this);
        this._ios = TKChartGridLineAnnotation.new();
        this._ios.style.stroke = TKStroke.strokeWithColor(new color_1.Color("Black").ios);
    }
    Object.defineProperty(ChartGridLineAnnotation.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    ChartGridLineAnnotation.prototype.update = function () {
        if (this.owner && this.owner.ios) {
            this.owner.ios.updateAnnotations();
        }
    };
    ChartGridLineAnnotation.prototype.onOwnerChanged = function () {
        if (!this.axisId) {
            console.log("WARNING: axisId property is mandatory for any anotation.");
            return;
        }
        if (!this.owner) {
            return;
        }
        var forAxis = this.owner.getAxixByID(this.axisId);
        if (forAxis) {
            this._ios.axis = forAxis.ios;
        }
        this.update();
    };
    ChartGridLineAnnotation.prototype.onValueChanged = function (data) {
        if (data.newValue) {
            this._ios.value = data.newValue;
            this.update();
        }
    };
    ChartGridLineAnnotation.prototype.onAxisIdChanged = function (data) {
        if (data.newValue && this.owner) {
            var forAxis = this.owner.getAxixByID(this.axisId);
            if (forAxis) {
                this._ios.axis = forAxis.ios;
                this.update();
            }
        }
    };
    ChartGridLineAnnotation.prototype.onZPositionChanged = function (data) {
        if (data.newValue) {
            switch (data.newValue.toLowerCase()) {
                case commonModule.ChartAnnotationZPosition.BellowSeries.toLowerCase():
                    this._ios.zPosition = TKChartAnnotationZPosition.TKChartAnnotationZPositionBelowSeries;
                    break;
                case commonModule.ChartAnnotationZPosition.AboveSeries.toLowerCase():
                    this._ios.zPosition = TKChartAnnotationZPosition.TKChartAnnotationZPositionAboveSeries;
                    break;
            }
        }
    };
    ChartGridLineAnnotation.prototype.onHiddenChanged = function (data) {
        this._ios.hidden = data.newValue;
        this.update();
    };
    ChartGridLineAnnotation.prototype.onStrokeWidthChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            this._ios.style.stroke.width = data.newValue;
            this.update();
        }
    };
    ChartGridLineAnnotation.prototype.onStrokeColorChanged = function (data) {
        if (data.newValue) {
            this._ios.style.stroke.color = (new color_1.Color(data.newValue)).ios;
            this.update();
        }
    };
    ChartGridLineAnnotation.prototype.onStrokeDashPatternChanged = function (data) {
        if (data.newValue) {
            var array = JSON.parse("[" + data.newValue + "]");
            if (array instanceof Array) {
                var nativeSource = NSMutableArray.new();
                var item = void 0, name_1, value = void 0;
                for (var i = 0; i < array.length; i++) {
                    item = array[i];
                    nativeSource.addObject(item);
                }
                this._ios.style.stroke.dashPattern = nativeSource;
                this.update();
            }
        }
    };
    return ChartGridLineAnnotation;
}(commonModule.ChartGridLineAnnotation));
exports.ChartGridLineAnnotation = ChartGridLineAnnotation;
var ChartPlotBandAnnotation = (function (_super) {
    __extends(ChartPlotBandAnnotation, _super);
    function ChartPlotBandAnnotation() {
        _super.call(this);
        this._ios = TKChartBandAnnotation.new();
        this._ios.style.stroke = TKStroke.strokeWithColor(new color_1.Color("Black").ios);
    }
    Object.defineProperty(ChartPlotBandAnnotation.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        enumerable: true,
        configurable: true
    });
    ChartPlotBandAnnotation.prototype.update = function () {
        if (this.owner && this.owner.ios) {
            this.owner.ios.updateAnnotations();
        }
    };
    ChartPlotBandAnnotation.prototype.onOwnerChanged = function () {
        if (!this.axisId) {
            console.log("WARNING: axisId property is mandatory for any anotation.");
            return;
        }
        if (!this.owner) {
            return;
        }
        var forAxis = this.owner.getAxixByID(this.axisId);
        if (forAxis) {
            this._ios.axis = forAxis.ios;
            this.update();
        }
    };
    ChartPlotBandAnnotation.prototype.onMinValueChanged = function (data) {
        if (this.ios.range) {
            this.ios.range.minimum = data.newValue;
        }
        else {
            this.ios.range = TKRange.rangeWithMinimumAndMaximum(data.newValue, (this.maxValue != undefined) ? this.maxValue : data.newValue);
        }
        this.update();
    };
    ChartPlotBandAnnotation.prototype.onMaxValueChanged = function (data) {
        if (this.ios.range) {
            this.ios.range.maximum = data.newValue;
        }
        else {
            this.ios.range = TKRange.rangeWithMinimumAndMaximum((this.minValue != undefined) ? this.minValue : data.newValue, data.newValue);
        }
        this.update();
    };
    ChartPlotBandAnnotation.prototype.onFillColorChanged = function (data) {
        if (data.newValue) {
            this._ios.style.fill = TKSolidFill.solidFillWithColor((new color_1.Color(data.newValue)).ios);
            this.update();
        }
    };
    ChartPlotBandAnnotation.prototype.onAxisIdChanged = function (data) {
        if (data.newValue && this.owner) {
            var forAxis = this.owner.getAxixByID(this.axisId);
            if (forAxis) {
                this._ios.axis = forAxis.ios;
                this.update();
            }
        }
    };
    ChartPlotBandAnnotation.prototype.onZPositionChanged = function (data) {
        if (data.newValue) {
            switch (data.newValue.toLowerCase()) {
                case commonModule.ChartAnnotationZPosition.BellowSeries.toLowerCase():
                    this._ios.zPosition = TKChartAnnotationZPosition.TKChartAnnotationZPositionBelowSeries;
                    break;
                case commonModule.ChartAnnotationZPosition.AboveSeries.toLowerCase():
                    this._ios.zPosition = TKChartAnnotationZPosition.TKChartAnnotationZPositionAboveSeries;
                    break;
            }
            this.update();
        }
    };
    ChartPlotBandAnnotation.prototype.onHiddenChanged = function (data) {
        this._ios.hidden = data.newValue;
        this.update();
    };
    ChartPlotBandAnnotation.prototype.onStrokeWidthChanged = function (data) {
        if (!isNaN(+data.newValue)) {
            this._ios.style.stroke.width = data.newValue;
            this.update();
        }
    };
    ChartPlotBandAnnotation.prototype.onStrokeColorChanged = function (data) {
        if (data.newValue) {
            this._ios.style.stroke.color = (new color_1.Color(data.newValue)).ios;
            this.update();
        }
    };
    ChartPlotBandAnnotation.prototype.onStrokeDashPatternChanged = function (data) {
        if (data.newValue) {
            var array = JSON.parse("[" + data.newValue + "]");
            if (array instanceof Array) {
                var nativeSource = NSMutableArray.new();
                var item = void 0, name_2, value = void 0;
                for (var i = 0; i < array.length; i++) {
                    item = array[i];
                    nativeSource.addObject(item);
                }
                this._ios.style.stroke.dashPattern = nativeSource;
                this.update();
            }
        }
    };
    return ChartPlotBandAnnotation;
}(commonModule.ChartPlotBandAnnotation));
exports.ChartPlotBandAnnotation = ChartPlotBandAnnotation;
var Trackball = (function (_super) {
    __extends(Trackball, _super);
    function Trackball() {
        _super.call(this);
    }
    Object.defineProperty(Trackball.prototype, "ios", {
        get: function () {
            return this._ios;
        },
        set: function (value) {
            this._ios = value;
            this.updateNativeSnapMode(this.snapMode);
            this.updateShowIntersectionPoints(this.showIntersectionPoints);
        },
        enumerable: true,
        configurable: true
    });
    Trackball.prototype.onSnapModeChanged = function (data) {
        if (!this._ios) {
            return;
        }
        if (data.newValue) {
            this.updateNativeSnapMode(data.newValue);
        }
    };
    Trackball.prototype.onShowIntersectionPointsChanged = function (data) {
        if (!this._ios) {
            return;
        }
        if (data.newValue) {
            this.updateShowIntersectionPoints(data.newValue);
        }
    };
    Trackball.prototype.updateShowIntersectionPoints = function (value) {
        if (value) {
            this.ios.line.style.pointShape.size = CGSizeMake(4, 4);
        }
        else {
            this.ios.line.style.pointShape.size = CGSizeZero;
        }
    };
    Trackball.prototype.updateNativeSnapMode = function (snapMode) {
        if (snapMode.toLowerCase() === commonModule.TrackballSnapMode.ClosestPoint.toLowerCase()) {
            this.ios.snapMode = TKChartTrackballSnapMode.TKChartTrackballSnapModeClosestPoint;
        }
        else if (snapMode.toLowerCase() === commonModule.TrackballSnapMode.AllClosestPoints.toLowerCase()) {
            this.ios.snapMode = TKChartTrackballSnapMode.TKChartTrackballSnapModeAllClosestPoints;
        }
        else {
            console.log("WARNING: Unsupported trackball snap mode set: " + snapMode);
        }
    };
    return Trackball;
}(commonModule.Trackball));
exports.Trackball = Trackball;
